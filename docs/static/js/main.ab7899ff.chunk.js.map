{"version":3,"sources":["runModel.ts","models.tsx","transformer.js","App.tsx","reportWebVitals.ts","index.tsx"],"names":["createModelCpu","model","a","InferenceSession","create","executionProviders","runModel","preprocessedData","start","Date","feeds","inputNames","run","outputData","end","inferenceTime","getTime","output","outputNames","console","error","Error","modelConfig","loadImage","imageSrc","Promise","resolve","reject","img","Image","onload","onerror","src","getModelImageSize","styleName","maxSize","imageDimensions","sizeList","imageSize","width","height","modelImageSize","i","length","size","getOutputDimension","image","getData","outputDimension","canvas","document","createElement","ctx","getContext","drawImage","imgData","getImageData","data","Float32Array","resultCanvas","maxModelImageSize","style","floatData","dataFromImage","ndarray","dataProcessed","ops","assign","pick","inputTensor","Tensor","set","modelFile","process","log","session","dataFromImageBack","dataProcessedBack","dataForImage","y","x","getElementById","idata","createImageData","putImageData","App","useState","setImageSrc","defaultStyle","setSizeList","selectStyle","setSelectedStyle","selectImageSize","setSelectedImageSize","hint","setHint","radioHandler","event","target","value","useEffect","prepareAndRunStyle","then","className","Object","keys","map","key","index","type","name","onChange","checked","id","item","file","files","reader","FileReader","readAsDataURL","result","href","data-ribbon","title","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ab7899ff.chunk.js","sourcesContent":["import {InferenceSession, Tensor} from 'onnxruntime-web';\r\n\r\nfunction init() {\r\n  // env.wasm.simd = false;\r\n}\r\n\r\nexport async function createModelCpu(model: string): Promise<InferenceSession> {\r\n  init();\r\n  return await InferenceSession.create(model, {executionProviders: ['wasm']});\r\n}\r\nexport async function createModelGpu(model: string): Promise<InferenceSession> {\r\n  init();\r\n  return await InferenceSession.create(model, {executionProviders: ['webgl']});\r\n}\r\n\r\nexport async function warmupModel(model: InferenceSession, dims: number[]) {\r\n  // OK. we generate a random input and call Session.run() as a warmup query\r\n  const size = dims.reduce((a, b) => a * b);\r\n  const warmupTensor = new Tensor('float32', new Float32Array(size), dims);\r\n\r\n  for (let i = 0; i < size; i++) {\r\n    warmupTensor.data[i] = Math.random() * 2.0 - 1.0;  // random value [-1.0, 1.0)\r\n  }\r\n  try {\r\n    const feeds: Record<string, Tensor> = {};\r\n    feeds[model.inputNames[0]] = warmupTensor;\r\n    await model.run(feeds);\r\n  } catch (e) {\r\n    console.error(e);\r\n  }\r\n}\r\n\r\nexport async function runModel(model: InferenceSession, preprocessedData: Tensor): Promise<[Tensor, number]> {\r\n  const start = new Date();\r\n  try {\r\n    const feeds: Record<string, Tensor> = {};\r\n    feeds[model.inputNames[0]] = preprocessedData;\r\n    const outputData = await model.run(feeds);\r\n    const end = new Date();\r\n    const inferenceTime = (end.getTime() - start.getTime());\r\n    const output = outputData[model.outputNames[0]];\r\n\r\n    return [output, inferenceTime];\r\n  } catch (e) {\r\n    console.error(e);\r\n    throw new Error();\r\n  }\r\n}","export const modelConfig: { [key: string]: number[] } = {\n  'candy': [135, 200, 270, 300, 350, 360, 400, 540, 1200],\n  'gogh': [135, 200, 300, 350, 400, 500, 1000, 1500, 4000],\n  'rain': [135, 200, 300, 350, 500, 1000],\n  'mosaic': [224],\n  'pointilism': [224],\n  'udnie': [224],\n}\n","import ndarray from \"ndarray\";\nimport ops from \"ndarray-ops\";\nimport {Tensor} from 'onnxruntime-web';\nimport { createModelCpu, runModel } from \"./runModel\";\nimport { modelConfig } from \"./models\";\n\nconst loadImage = imageSrc =>\n  new Promise((resolve, reject) => {\n    const img = new Image()\n\n    // the following handler will fire after the successful loading of the image\n    img.onload = () => {\n      resolve(img)\n    }\n\n    // and this handler will fire if there was an error with the image (like if it's not really an image or a corrupted one)\n    img.onerror = () => {\n      reject('There was some problem with the image.')\n    }\n\n    img.src = imageSrc\n  })\n\n\nfunction getModelImageSize(styleName, maxSize, imageDimensions) {\n  const sizeList = modelConfig[styleName];\n  const imageSize = imageDimensions.width > imageDimensions.height ? imageDimensions.width : imageDimensions.height;\n  let modelImageSize = 0;\n  for(let len = sizeList.length, i = len - 1; i >= 0 ; i--) {\n    const size =  sizeList[i];\n    if (size > maxSize) {\n      continue;\n    }\n    if (size <= imageSize) {\n      modelImageSize = modelImageSize || size;\n      break;\n    }\n    modelImageSize = size;\n  }\n  modelImageSize = modelImageSize || sizeList[0];\n  return modelImageSize;\n}\n\n\nfunction getOutputDimension(image, modelImageSize) {\n  let height = modelImageSize;\n  let width = image.width * (modelImageSize / image.height);\n  if (image.width > image.height) {\n    width = modelImageSize;\n    height = image.height * (modelImageSize / image.width);\n  }\n  return {width, height};\n}\n\nasync function getData(image, modelImageSize, outputDimension) {\n  let canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = modelImageSize;\n  canvas.height = modelImageSize;\n\n  ctx.drawImage(image, 0, 0, outputDimension.width, outputDimension.height);\n  const imgData = ctx.getImageData(0, 0, modelImageSize, modelImageSize).data;\n  return new Float32Array(imgData);\n}\n\nexport async function prepareAndRunStyle(\n  imageSrc,\n  resultCanvas,\n  maxModelImageSize,\n  style,\n) {\n  const image = await loadImage(imageSrc)\n  const modelImageSize = getModelImageSize(\n    style, maxModelImageSize, {width: image.width, height: image.height});\n  const outputDimension = getOutputDimension(image, modelImageSize);\n  let floatData = await getData(image, modelImageSize, outputDimension);\n  let dataFromImage = ndarray(floatData, [modelImageSize, modelImageSize, 4]);\n  let dataProcessed = ndarray(new Float32Array(modelImageSize * modelImageSize * 3), [\n    1,\n    3,\n    modelImageSize,\n    modelImageSize,\n  ]);\n  ops.assign(\n    dataProcessed.pick(0, 2, null, null),\n    dataFromImage.pick(null, null, 2)\n  );\n  ops.assign(\n    dataProcessed.pick(0, 1, null, null),\n    dataFromImage.pick(null, null, 1)\n  );\n  ops.assign(\n    dataProcessed.pick(0, 0, null, null),\n    dataFromImage.pick(null, null, 0)\n  );\n\n  const inputTensor = new Tensor(\n    \"float32\",\n    new Float32Array(3 * modelImageSize * modelImageSize),\n    [1, 3, modelImageSize, modelImageSize]\n  );\n  inputTensor.data.set(dataProcessed.data);\n  dataFromImage = null;\n  dataProcessed = null;\n  // Creat the session and load the pre-trained model\n\n  const modelFile = `${process.env.PUBLIC_URL}/models/${style}${modelImageSize}.onnx`;\n  console.log(\"loading onnx model\");\n  let session = await createModelCpu(modelFile);\n  console.log(\"transforming\");\n  const [output, time] = await runModel(session, inputTensor);\n  console.log(\"finished\");\n  session = null;\n  let outputData = output.data;\n  const dataFromImageBack = ndarray(\n    new Float32Array(modelImageSize * modelImageSize * 4),\n    [modelImageSize, modelImageSize, 4]\n  );\n  const dataProcessedBack = ndarray(new Float32Array(outputData), [\n    1,\n    3,\n    modelImageSize,\n    modelImageSize,\n  ]);\n  ops.assign(\n    dataFromImageBack.pick(null, null, 0),\n    dataProcessedBack.pick(0, 0, null, null)\n  );\n  ops.assign(\n    dataFromImageBack.pick(null, null, 1),\n    dataProcessedBack.pick(0, 1, null, null)\n  );\n  ops.assign(\n    dataFromImageBack.pick(null, null, 2),\n    dataProcessedBack.pick(0, 2, null, null)\n  );\n  let dataForImage = dataFromImageBack.data;\n  for (let y = 0; y < modelImageSize; y++) {\n    for (let x = 0; x < modelImageSize; x++) {\n      let pos = (y * modelImageSize + x) * 4; // position in buffer based on x and y\n      dataForImage[pos + 3] = 255; // set alpha channel\n    }\n  }\n  let canvas = document.getElementById(resultCanvas);\n  let ctx = canvas.getContext(\"2d\");\n  canvas.width = outputDimension.width;\n  canvas.height = outputDimension.height;\n  // create imageData object\n  let idata = ctx.createImageData(modelImageSize, modelImageSize);\n  // set our buffer as source\n  idata.data.set(dataForImage);\n  // update canvas with new data\n  ctx.putImageData(idata, 0, 0);\n}\n","import React, { useState, useEffect } from 'react';\nimport { prepareAndRunStyle } from \"./transformer.js\";\nimport './App.css';\nimport './gh-fork-ribbon.css';\nimport { modelConfig } from \"./models\";\n\nfunction App() {\n\n  const [imageSrc, setImageSrc] = useState<any>();\n  const defaultStyle = 'rain'\n  const [sizeList = modelConfig[defaultStyle], setSizeList] = useState<number[]>();\n  const [selectStyle = defaultStyle, setSelectedStyle] = useState<any>();\n  const [selectImageSize = 135, setSelectedImageSize] = useState<any>();\n  const [hint = \"please upload a image\", setHint] = useState<string>();\n\n  const radioHandler = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const style = event.target.value;\n    setSelectedStyle(style);\n    setSizeList(modelConfig[style]);\n  };\n\n  const selectHandler = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    const size = event.target.value;\n    setSelectedImageSize(size);\n  };\n\n  const fileOnChange = (event: any) => {\n    const file = event.target.files[0];\n    if (!file) {\n      return;\n    }\n    const reader = new FileReader();\n\n    reader.readAsDataURL(file);\n    reader.onload = () => {\n      setImageSrc(reader.result);\n    };\n  };\n\n    useEffect(() => {\n    if (imageSrc) {\n      setHint(\"transforming ...\")\n      prepareAndRunStyle(\n        imageSrc,\n        \"resultCanvas\",\n        selectImageSize,  // selectSize,\n        selectStyle,\n      ).then((value) => {\n        setHint(\"\");\n      });\n    } else {\n    }\n  }, [imageSrc, selectImageSize, selectStyle]);\n\n  return (\n    <div className=\"App\">\n\n      <header className=\"App-header\">\n        <div>\n          {Object.keys(modelConfig).map(function(key, index) {\n            return (\n              <label key={key}>\n                <input type=\"radio\" name=\"style\" value={key} onChange={radioHandler} checked={key === selectStyle}/>\n                <img src={`${process.env.PUBLIC_URL}/assets/images/styles/${key}.jpg`}/>\n              </label>\n            )})}\n        </div>\n        <div>\n          Output image size:\n          <select name=\"imageSize\" id=\"imageSize\" value={selectImageSize} onChange={selectHandler}>\n            {sizeList.map(item => {\n              return (\n                <option key={item} value={item}>\n                  {item}\n                </option>\n              );\n            })}\n          </select>\n        </div>\n        <input\n          type=\"file\"\n          name=\"backgroundImg\"\n          onChange={fileOnChange}\n        ></input>\n        <div>\n          { hint }\n        </div>\n        <canvas id=\"resultCanvas\" width={selectImageSize} height={selectImageSize} />\n      </header>\n      <a className=\"github-fork-ribbon\" href=\"https://github.com/vicalloy/image-transformer\" data-ribbon=\"Fork me on GitHub\"\n         title=\"Fork me on GitHub\">Fork me on GitHub</a>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}